<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GiggLinuX — Kernel Console</title>
  <style>
    :root {
      --bg: #000;
      --white: #eaeaea;
      --gray: #9aa3a1;
      --green: #7bd389;
      --muted-green: #3f7f63;
      --panel-bg: rgba(0,0,0,0.55);
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--white);font-family:"Ubuntu Mono",monospace;}
    body{display:flex;flex-direction:column;gap:12px;padding:12px;box-sizing:border-box;}
    .statusbar{display:flex;justify-content:space-between;align-items:center;padding:8px 12px;background:#080808;border:1px solid rgba(255,255,255,0.04);}
    .status-left{color:var(--green);font-weight:700;}
    .status-right{color:var(--gray);display:flex;gap:12px;font-size:14px;}
    .tabs{display:flex;gap:8px;padding:6px 12px;background:#070707;border-top:1px solid rgba(255,255,255,0.02);}
    .tab{color:var(--green);padding:6px 10px;border:1px solid rgba(255,255,255,0.04);text-decoration:none;text-transform:uppercase;font-size:13px;}
    .searchbar{display:flex;align-items:center;gap:8px;padding:8px 12px;background:#050505;border:1px dashed rgba(255,255,255,0.02);}
    .prompt{color:var(--muted-green);margin-right:6px;}
    .console{flex:1 1 auto;background:linear-gradient(#000,#050505);padding:16px;border:1px solid rgba(255,255,255,0.04);font-size:13px;line-height:1.45;white-space:pre-wrap;overflow:auto;min-height:420px;color:var(--white);}
    .ok{color:var(--white);}        /* Log-Ausgaben in Weiß */
    .warn{color:var(--muted-green);}
    .err{color:#ff6b6b;}
    .dim{color:var(--gray);}
    @media(min-width:1000px){
      body{padding:20px 80px;}
    }
  </style>
</head>
<body>

  <div class="statusbar">
    <div class="status-left">Willkommen auf meiner Website</div>
    <div class="status-right">
      <div id="date" class="dim"></div>
      <div id="clock" class="dim"></div>
    </div>
  </div>

  <div class="tabs">
    <a class="tab" href="index.html">Home</a>
    <a class="tab" href="projekte.html">Projekte</a>
  </div>

  <div class="searchbar">
    <div class="prompt">chuck@norris:~#</div>
    <form action="https://www.google.com/search" method="get" style="display:flex;gap:8px;align-items:center;">
      <input type="text" name="q" placeholder="DROP TABLES;" style="background:#000;color:var(--white);border:1px solid rgba(255,255,255,0.05);padding:6px 8px;font-family:inherit;font-size:14px;">
      <button type="submit" style="background:#0a0a0a;color:var(--green);border:1px solid rgba(255,255,255,0.05);padding:6px 10px;cursor:pointer;">run</button>
    </form>
  </div>

  <!-- Nur die Konsole bleibt -->
  <div class="console" id="console" aria-live="polite" aria-atomic="false"></div>

<script>
  // Datum / Uhrzeit
  function updateClock() {
    const now = new Date();
    document.getElementById('clock').textContent =
      `[${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}:${String(now.getSeconds()).padStart(2,'0')}]`;
  }
  function updateDate() {
    const now = new Date();
    document.getElementById('date').textContent = now.toLocaleDateString('de-DE');
  }
  setInterval(updateClock,1000);
  updateClock(); updateDate();

  // Console helpers
  const consoleEl = document.getElementById('console');
  const bootStart = performance.now();
  function ts() {
    const ms = (performance.now() - bootStart) / 1000;
    return `[ ${ms.toFixed(6).padStart(10,' ')}]`;
  }
  function clog(line, cls='ok') {
    const esc = String(line).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    const html = `${ts()} <span class="${cls}">${esc}</span>\n`;
    consoleEl.insertAdjacentHTML('beforeend', html);
    consoleEl.scrollTop = consoleEl.scrollHeight;
  }
  const sleep = ms => new Promise(r=>setTimeout(r,ms));

  // --- Hacker News in die Konsole schreiben NACH "stay safe" ---
  async function printNewsToConsole() {
    try {
      // Überschrift "News" in CLI-Art
      const NEWS_ASCII = String.raw`
 _   _            _                _  _                             
| | | | __ _  ___| | _____ _ __   | \| | _____       ______
| |_| |/ _` |/ __| |/ / _ \ '__|  | .` |/ _ \ \ /\ / /  __/
|  _  | (_| | (__|   <  __/ |     | |\  |  __/\ V  V / __ \
|_| |_|\__,_|\___|_|\_\___|_|     |_| \_|\___| \_/\_/ |___/
`;
     consoleEl.insertAdjacentHTML('beforeend', `<pre>${NEWS_ASCII}</pre>`);
      consoleEl.scrollTop = consoleEl.scrollHeight;

      const FEED  = 'https://news.ycombinator.com/rss';
      const PROXY = (u)=>'https://api.allorigins.win/raw?url=' + encodeURIComponent(u);
      const LIMIT = 25;

      const xmlText = await (async function fetchRSS(){
        const tries = [
          {name:'direct', url: FEED},
          {name:'proxy',  url: PROXY(FEED)}
        ];
        let lastErr=null;
        for (const t of tries){
          try{
            const res = await fetch(t.url, {cache:'no-store'});
            if(!res.ok) throw new Error(`${t.name} HTTP ${res.status}`);
            return await res.text();
          } catch(e){ lastErr=e; }
        }
        throw lastErr || new Error('Abruf fehlgeschlagen');
      })();

      const doc = new DOMParser().parseFromString(xmlText, 'application/xml');
      if (doc.querySelector('parsererror')) throw new Error('RSS-Parsing fehlgeschlagen');

      const items = [...doc.querySelectorAll('item')].slice(0, LIMIT).map(it=>{
        const title = it.querySelector('title')?.textContent?.trim() || '(ohne Titel)';
        const link  = it.querySelector('link')?.textContent?.trim() || '#';
        const pub   = it.querySelector('pubDate')?.textContent?.trim() || '';
        return { title, link, pub };
      });

      function fmt(pub){
        const d = new Date(pub);
        if (isNaN(d.getTime())) return '????-??-?? ??:??';
        const y = d.getFullYear();
        const M = String(d.getMonth()+1).padStart(2,'0');
        const D = String(d.getDate()).padStart(2,'0');
        const h = String(d.getHours()).padStart(2,'0');
        const m = String(d.getMinutes()).padStart(2,'0');
        return `${y}-${M}-${D} ${h}:${m}`;
      }

      // Jede News als einzelne Kernel-Zeile untereinander
      for (const it of items){
        const tsLocal = fmt(it.pub);
        // anklickbarer Titel (Link öffnet im neuen Tab)
        const lineHtml = `${ts()} <span class="ok">Hacker News:</span> ` +
          `<a href="${it.link || '#'}" target="_blank" rel="noopener noreferrer" style="color:#eaeaea;text-decoration:none;">` +
          `${String(it.title).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</a>\n`;
        consoleEl.insertAdjacentHTML('beforeend', `[ ${tsLocal} ] ${lineHtml}`);
        consoleEl.scrollTop = consoleEl.scrollHeight;
      }
    } catch(e) {
      clog(`[ FEHLER ] Hacker News: ${e.message}`, 'err');
    }
  }

  // Robust IP/Geo loading with timeouts and fallback
  (async () => {
    clog('Booting Kernel: GiggLinuX (console-only)...', 'ok'); await sleep(350);
    clog('init: starting subsystems: coffee, humor, chaos ...', 'ok'); await sleep(400);
    clog("userland: executing whoami -> chucknorris", 'ok'); await sleep(500);
    clog('tasks: backe käsekuchen', 'ok'); await sleep(600);
    clog('tasks: putze klo', 'ok'); await sleep(600);
    clog('net: preparing interface eth0 ...', 'ok'); await sleep(700);

    const withTimeout = (p, ms, label) => Promise.race([
      p, new Promise((_, rej) => setTimeout(() => rej(new Error(label + ' timeout')), ms))
    ]);

    try {
      // Try ipify for IP
      let ip;
      try {
        const r = await withTimeout(fetch('https://api.ipify.org?format=json', {cache:'no-store'}), 7000, 'ipify');
        if (!r.ok) throw new Error('ipify HTTP ' + r.status);
        const j = await r.json();
        ip = j.ip;
        clog(`net: assigned address ${ip}`, 'ok');
      } catch (e1) {
        clog('net: ipify failed or blocked -> trying ipapi directly', 'warn');
        const r2 = await withTimeout(fetch('https://ipapi.co/json/', {cache:'no-store'}), 8000, 'ipapi-fallback');
        if (!r2.ok) throw new Error('ipapi HTTP ' + r2.status);
        const j2 = await r2.json();
        ip = j2.ip;
        clog(`net: assigned address ${ip}`, 'ok');
        const city = j2.city || '';
        const region = j2.region || '';
        const country = j2.country_name || j2.country || '';
        const postal = j2.postal || '';
        const lat = j2.latitude ?? j2.lat ?? '';
        const lon = j2.longitude ?? j2.lon ?? '';
        const parts = [];
        if (postal) parts.push(postal);
        if (city) parts.push(city);
        if (region && region !== city) parts.push(region);
        if (country) parts.push(country);
        const locText = parts.length ? parts.join(', ') : 'Nicht verfügbar';
        clog(`geo: resolved -> ${locText}`, 'ok'); await sleep(300);
        if (lat && lon) clog(`coords: ${lat}, ${lon}`, 'ok');
        clog('services: user-space ready.', 'ok');
        clog('security: remember to stay safe ;)', 'ok');

        // === HIER: News NACH "stay safe" ===
        await printNewsToConsole();

        return; // done via fallback
      }

      // If we have IP, query ipapi for geo about that IP
      try {
        const rgeo = await withTimeout(fetch(`https://ipapi.co/${encodeURIComponent(ip)}/json/`, {cache:'no-store'}), 8000, 'ipapi-geo');
        if (!rgeo.ok) throw new Error('ipapi-geo HTTP ' + rgeo.status);
        const g = await rgeo.json();
        const city = g.city || '';
        const region = g.region || '';
        const country = g.country_name || g.country || '';
        const postal = g.postal || '';
        const lat = g.latitude ?? g.lat ?? '';
        const lon = g.longitude ?? g.lon ?? '';
        const parts = [];
        if (postal) parts.push(postal);
        if (city) parts.push(city);
        if (region && region !== city) parts.push(region);
        if (country) parts.push(country);
        const locText = parts.length ? parts.join(', ') : 'Nicht verfügbar';
        clog(`geo: resolved -> ${locText}`, 'ok'); await sleep(300);
        if (lat && lon) clog(`coords: ${lat}, ${lon}`, 'ok');
        clog('services: user-space ready.', 'ok'); await sleep(200);
        clog('security: remember to stay safe ;)', 'ok');

        // === HIER: News NACH "stay safe" ===
        await printNewsToConsole();

      } catch (eGeo) {
        clog('geo: failed to resolve location (ipapi)', 'warn');
        clog('services: user-space ready (partial).', 'ok');
        clog('security: remember to stay safe ;)', 'ok');

        // === HIER: News NACH "stay safe" (auch wenn Geo fehlschlug) ===
        await printNewsToConsole();
      }
    } catch (e) {
      clog('net: failed to obtain IP/location (offline)', 'err');
      clog('security: remember to stay safe ;)', 'ok');

      // === HIER: News auch im Offline-/Fehlerfall versuchen ===
      try { await printNewsToConsole(); } catch(_) {}
      console.error(e);
    }
  })();
</script>

  

</body>
</html>
