<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GiggLinuX — Kernel Mode</title>
  <style>
    :root {
      --bg: #000000;
      --white: #eaeaea;
      --gray: #a0a0a0;
      --green: #00ff00;
      --red: #ff5555;
      --yellow: #ffdd00;
      --blue: #00aaff;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--white);
      font-family: "Ubuntu Mono", monospace;
    }

    body {
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .statusbar {
      flex: 0 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 12px;
      border-bottom: 1px solid var(--gray);
      background: #111;
      color: var(--green);
    }

    .statusbar .left { font-weight: bold; }
    .statusbar .right { display: flex; gap: 16px; color: var(--gray); }

    .tabs {
      flex: 0 0 auto;
      display: flex;
      gap: 8px;
      padding: 6px 12px;
      background: #080808;
      border-bottom: 1px solid var(--gray);
    }
    .tab {
      color: var(--green);
      text-decoration: none;
      border: 1px solid var(--gray);
      padding: 4px 10px;
      background: #000;
      text-transform: uppercase;
    }
    .tab:hover { background: #0f0f0f; }

    .searchbar {
      flex: 0 0 auto;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      border-bottom: 1px dashed var(--gray);
      background: #000;
      color: var(--gray);
    }

    input[type="text"] {
      width: 360px;
      background: #000;
      color: var(--white);
      border: 1px solid var(--gray);
      padding: 6px 8px;
      outline: none;
      font-family: "Ubuntu Mono", monospace;
    }

    button {
      background: #111;
      color: var(--green);
      border: 1px solid var(--gray);
      padding: 4px 10px;
      cursor: pointer;
    }

    .console {
      flex: 1 1 auto;
      overflow: auto;
      padding: 12px;
      line-height: 1.45;
      white-space: pre-wrap;
      font-size: 14px;
    }

    .ok { color: var(--green); }
    .warn { color: var(--yellow); }
    .err { color: var(--red); }
    .dim { color: var(--gray); }

    .footer, .social-icons, h1, p { display: none; }
  </style>
</head>
<body>

  <div class="statusbar">
    <div class="left">Willkommen auf meiner Website</div>
    <div class="right">
      <span id="date"></span>
      <span id="clock"></span>
    </div>
  </div>

  <div class="tabs">
    <a class="tab" href="index.html">Home</a>
    <a class="tab" href="ueber-mich.html">Über mich</a>
    <a class="tab" href="projekte.html">Projekte</a>
    <a class="tab" href="kontakt.html">Kontakt</a>
  </div>

  <div class="searchbar">
    <span class="dim">chuck@norris:~#</span>
    <form action="https://www.google.com/search" method="get">
      <input type="text" name="q" placeholder="SELECT * FROM users WHERE 'x'='x' --">
      <button type="submit">run</button>
    </form>
  </div>

  <div class="console" id="info"></div>

  <script>
    // Datum / Uhrzeit
    function updateClock() {
      const now = new Date();
      document.getElementById('clock').textContent =
        `[${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}:${String(now.getSeconds()).padStart(2,'0')}]`;
    }
    function updateDate() {
      const now = new Date();
      document.getElementById('date').textContent = now.toLocaleDateString('de-DE');
    }
    setInterval(updateClock, 1000);
    updateClock(); updateDate();

    // Logging
    const bootStart = performance.now();
    function ts() {
      const ms = (performance.now() - bootStart) / 1000;
      return `[ ${ms.toFixed(6).padStart(10, ' ')}]`;
    }
    function log(line, cls="ok") {
      const info = document.getElementById("info");
      info.insertAdjacentHTML("beforeend", `${ts()} <span class="${cls}">${line}</span>\n`);
      info.scrollTop = info.scrollHeight;
    }
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    // User Agent Parser
    function parseUA() {
      const ua = navigator.userAgent;
      const browser =
        ua.includes("Firefox") ? "Firefox" :
        ua.includes("Edg/") ? "Edge" :
        ua.includes("Chrome") ? "Chrome" :
        ua.includes("Safari") ? "Safari" : "Unbekannt";
      const version = (ua.match(/(Firefox|Edg|Chrome)\/([\d.]+)/) || [])[2] ||
                      (ua.match(/Version\/([\d.]+).*Safari/) || [])[1] || "";
      let os = "Unbekannt";
      if (/Windows NT/.test(ua)) os = "Windows";
      else if (/Mac OS X/.test(ua)) os = "macOS";
      else if (/Android/.test(ua)) os = "Android";
      else if (/iPhone|iPad|iPod/.test(ua)) os = "iOS";
      return { browser, version, os };
    }

(async () => {
    log("net: bringing up interface eth0 ...");                  await sleep(300);

    // kleiner Timeout-Helper
    const withTimeout = (p, ms, label) => Promise.race([
      p, new Promise((_, rej) => setTimeout(() => rej(new Error(label+" timeout")), ms))
    ]);

    try {
      let ip, city, country, region, postal;

      // 1) Primär: IP von ipify
      try {
        const r1 = await withTimeout(fetch('https://api.ipify.org?format=json', {
          cache: 'no-store'
        }), 6000, 'ipify');
        if (!r1.ok) throw new Error('ipify HTTP ' + r1.status);
        ({ ip } = await r1.json());
        log(`net: assigned IP address ${ip}`);                    await sleep(100);
      } catch (e) {
        log("net: primary IP service failed, trying fallback", "warn"); await sleep(400);
        const r2 = await withTimeout(fetch('https://ipapi.co/json/', { cache: 'no-store' }), 7000, 'ipapi');
        if (!r2.ok) throw new Error('ipapi HTTP ' + r2.status);
        const j2 = await r2.json();
        ip = j2.ip;
        city = j2.city; country = j2.country_name || j2.country;
        region = j2.region; postal = j2.postal;
        log(`net: assigned IP address ${ip}`);                    await sleep(600);
        const loc2 = [postal, city, region, country].filter(Boolean).join(', ') || 'unavailable';
        log(`geo: resolved location -> ${city || 'unknown'}, ${country || ''}`); await sleep(600);
        log(`addr: ${loc2}`);                                     await sleep(200);
        log("services: all systems operational.");                await sleep(300);
        log("security: remember to stay safe ;)");                await sleep(300);
        return; // wir sind fertig (Fallback-Weg)
      }

      // 2) Geo zu genau dieser IP auflösen
      try {
        const r3 = await withTimeout(fetch(`https://ipapi.co/${ip}/json/`, { cache: 'no-store' }), 7000, 'ipapi-geo');
        if (!r3.ok) throw new Error('ipapi-geo HTTP ' + r3.status);
        const g = await r3.json();
        city = g.city; country = g.country_name || g.country;
        region = g.region; postal = g.postal;

        log(`geo: resolved location -> ${city || 'unknown'}, ${country || ''}`); await sleep(600);
        const loc = [postal, city, region, country].filter(Boolean).join(', ') || 'unavailable';
        log(`addr: ${loc}`);                                       await sleep(300);
      } catch (e) {
        log("geo: failed to resolve location", "warn");            await sleep(100);
      }

      log("services: all systems operational.");                  await sleep(200);
      log("security: remember to stay safe ;)");                  await sleep(200);

    } catch (e) {
      log("net: failed to obtain IP/location (offline mode)", "warn");
      console.error(e);
      }
    })();
  </script>
</body>
</html>
